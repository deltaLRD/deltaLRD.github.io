<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++ exam ans anlaysis</title>
    <url>/2021/12/19/C-exam-ans-anlaysis/</url>
    <content><![CDATA[<h1 id="C-解析"><a href="#C-解析" class="headerlink" title="C++ 解析"></a>C++ 解析</h1><p><del>太多了，还是去看答案吧</del></p>
<h3 id="第10题"><a href="#第10题" class="headerlink" title="第10题"></a>第10题</h3><p><code>typedef int *INTERGER;</code>其实可以把这个看成<code>typedef int* INTERGER;</code>这样是不是就清楚多了。所以<br><code>INTERGER p</code> == <code>int* p</code><br><code>INTERGER *p</code> == <code>int* *p</code> == <code>int **p</code> == <code>int** p</code></p>
<h3 id="第12题"><a href="#第12题" class="headerlink" title="第12题"></a>第12题</h3><p>函数重载的关键是重载了以后电脑到底还能不能知道你到底想调用哪个函数</p>
<p>比如</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span></span>&#123;<span class="keyword">return</span>;&#125; <span class="comment">//函数1</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">f</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span></span>&#123;<span class="keyword">return</span> <span class="number">0.0</span>;&#125;<span class="comment">//函数2</span></span><br><span class="line"><span class="built_in">f</span>(<span class="number">1</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>这个时候电脑就不知道我们要做什么了，<del>换了我我也不能</del>因为两个函数都叫<code>f</code>而且传入的参数都一样</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span></span>&#123;<span class="keyword">return</span>;&#125; <span class="comment">//函数1</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">f</span><span class="params">(<span class="type">int</span>)</span></span>&#123;<span class="keyword">return</span> <span class="number">0.0</span>;&#125;<span class="comment">//函数2</span></span><br><span class="line"><span class="built_in">f</span>(<span class="number">1</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>这样就能知道了。</p>
<p>所以题目里也一样，只要函数列表里面的参数不一样就能重载。</p>
<h3 id="第15题"><a href="#第15题" class="headerlink" title="第15题"></a>第15题</h3><p><code>MyDERIVED</code>保护继承了<code>MyBASE</code>那么<code>MyBASE</code>里面的<code>public</code>的东西全部变成<code>protected</code>。<code>MyBASE</code>的<code>private</code>无法被访问。</p>
<p>所以我们只要数一数<code>MyBASE</code>里面<code>public</code>和<code>MyDERIVED</code>里面<code>protected</code>的东西就可以了。</p>
<h3 id="第17题"><a href="#第17题" class="headerlink" title="第17题"></a>第17题</h3><p>当一个类里面有形如<code>virtual [type] function()=0</code>那么这个类就是抽象类，抽象类不能实例化。</p>
<p>当一个函数里面有虚函数的时候形如<code>virtual [type] function()&#123;&#125;</code>同时这个类被别的类继承，那么这个类就是虚基类。</p>
<h3 id="第18题"><a href="#第18题" class="headerlink" title="第18题"></a>第18题</h3><p><code>cin&gt;&gt;x;</code>这是我们常见的c++里的输入。但<code>cin</code>本质上是个对象，是一个<code>istream</code>类实例化的对象。这里<code>istream</code>表示输入流，<code>i</code> == <code>in</code>输入，<code>stream</code>英文里的流，我们可以想象数据是一个个流进程序里的。</p>
<p>所以题目里说<code>ifstream</code>就是<code>i</code> == <code>in</code> 输入，<code>f</code> == <code>file</code>文件，<code>stream</code>流。<del>很通俗易懂不是吗</del></p>
<p>选项里的<code>ios</code>就是<code>i</code> == <code>in</code> 输入，<code>o</code> == <code>out</code>输入，<code>s</code> == <code>stream</code>流。<code>ios</code> == <del>苹果手机操作系统</del> == 输入输出流。<code>ios::in</code>的意思就是输入输出流里面的输入</p>
<h3 id="第19题"><a href="#第19题" class="headerlink" title="第19题"></a>第19题</h3><p>看看答案。</p>
<h3 id="第20题"><a href="#第20题" class="headerlink" title="第20题"></a>第20题</h3><p>首先我们需要知道一个公理</p>
<blockquote>
<p>先有老子才能有儿子</p>
</blockquote>
<p>所以B继承A，</p>
<p>先要执行A的构造函数，</p>
<p>再执行B的构造函数，</p>
<p>B的构造函数里又要new一个A出来，</p>
<p>所以还要再执行A的构造函数，</p>
<p>然后我们就开始销毁B，</p>
<p>执行B的析构函数，</p>
<p>B的析构函数里还要销毁new出来的A，</p>
<p>所以还要执行A的析构，</p>
<p>B析构完以后还要把继承下来的A析构，</p>
<p>所以还有个A的析构函数。</p>
<p><del>累死了</del></p>
<h2 id="第二大题"><a href="#第二大题" class="headerlink" title="第二大题"></a>第二大题</h2><h3 id="第2题"><a href="#第2题" class="headerlink" title="第2题"></a>第2题</h3><p><code>::a</code>是全局的<code>a</code>。</p>
<h3 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h3><p>函数里<code>&amp;a</code>会影响函数外面变量的值，</p>
<p><code>*a</code>会影响所指向的内存的值，但指针本身不会。</p>
<h3 id="第4题"><a href="#第4题" class="headerlink" title="第4题"></a>第4题</h3><p>难点是<code>static</code>，<code>static</code>只会初始化变量一次，一次结束以后就算再遇到初始化语句直接忽略。</p>
<blockquote>
<p>static只能作用与static所在的作用域和次级作用域</p>
</blockquote>
<h3 id="第5题"><a href="#第5题" class="headerlink" title="第5题"></a>第5题</h3><p>难点是函数指针。</p>
<p>代码翻译成人话就是输出$x^2-x^3$</p>
<p>函数指针具体用法看书。</p>
<h3 id="第6题"><a href="#第6题" class="headerlink" title="第6题"></a>第6题</h3><p><del>这题我也做错了</del></p>
<p><code>w[k][k]</code>是一个<code>char</code>类型的变量<code>&amp;w[k][k]</code>就是一个地址也可以当做一个指针。</p>
<p><code>cout</code>如果接了一个字符指针，他会一直输出当前字符，并且看下一个字符是啥如果不是<code>\0</code>那么就继续。</p>
<p>这里就是比较不容易发现，发现了就挺好做的。</p>
<h3 id="第8题"><a href="#第8题" class="headerlink" title="第8题"></a>第8题</h3><p>好好看看答案，二级指针比较难。</p>
<h3 id="第10题-1"><a href="#第10题-1" class="headerlink" title="第10题"></a>第10题</h3><p>被virtual修饰的函数，如果被继承，在派生类中，如果进行了重构，那么就默认以重构以后的函数为准，重构前的函数可以直接不看。</p>
<p>指向基类的的指针可以指向派生类。</p>
<h2 id="第4大题"><a href="#第4大题" class="headerlink" title="第4大题"></a>第4大题</h2><h3 id="第3题"><a href="#第3题" class="headerlink" title="第3题"></a>第3题</h3><p><del>最后一空直接放掉吧</del></p>
<p>好好看答案</p>
<h2 id="第5大题"><a href="#第5大题" class="headerlink" title="第5大题"></a>第5大题</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FUN</span>&#123;</span><br><span class="line">    <span class="type">float</span> a,b;</span><br><span class="line">    <span class="type">float</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FUN</span>(<span class="type">float</span> t1, <span class="type">float</span> t2):<span class="built_in">a</span>(t1),<span class="built_in">b</span>(t2)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">f1</span><span class="params">(<span class="type">float</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a*<span class="built_in">cos</span>(x)+b*<span class="built_in">sin</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">f2</span><span class="params">(<span class="type">float</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> -a*<span class="built_in">sin</span>(x)+b*<span class="built_in">sin</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">double</span> tmp_x=<span class="number">2l</span>f;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">abs</span>(<span class="built_in">f1</span>(tmp_x)) &gt;= <span class="number">1e-5</span>)&#123;</span><br><span class="line">            tmp_x = tmp_x - <span class="built_in">f1</span>(tmp_x)/<span class="built_in">f2</span>(tmp_x);</span><br><span class="line">        &#125;</span><br><span class="line">        x = tmp_x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">fun</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;方程的解为: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;x &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">0</span>,b=<span class="number">0</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入方程的系数: &quot;</span>;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    FUN fun = <span class="built_in">FUN</span>(a,b);</span><br><span class="line">    fun.<span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>CET-4 考后感</title>
    <url>/2021/12/18/CET-4-%E8%80%83%E5%90%8E%E6%84%9F/</url>
    <content><![CDATA[<h2 id="收音机vs耳机（内置了垃圾收音机）"><a href="#收音机vs耳机（内置了垃圾收音机）" class="headerlink" title="收音机vs耳机（内置了垃圾收音机）"></a>收音机vs耳机（内置了<del>垃圾</del>收音机）</h2><p>四级考前我心虚，还是去买了个耳机，结果里面没电池。就不乐意再下去买电池了。<br>然后我拿出高考用的收音机，在网上找学校的电台，找到是是FM72.8。结果一听没声音。然后就用室友的耳机试结果也没声音，然后我切回收音机，把天线拉出来，结果好像有声音了。<br>然后我切回FM72.8拉开所有天线，有了声音。然后室友把他们的耳机插上了耳机<del>耳机插耳机：）</del>结果也有声音了<br>但底噪好像比我的大。<br>考试的时候看好多人还是拿的收音机，果然收音机<code>yyds</code>。</p>
<h2 id="作文"><a href="#作文" class="headerlink" title="作文"></a>作文</h2><p>作文太赶了，我差点没写完。<br>还差5行没写完，而且字越来越丑<del>本来也够丑的了</del></p>
<h2 id="听力"><a href="#听力" class="headerlink" title="听力"></a>听力</h2><p>四级考试作文和听力先考，然后听力考完立马收答题卡，弄的我只能听一道涂一道，好不习惯，但没什么大碍。<br>听力难度总体正常，没啥可说的。</p>
<h2 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h2><p>四级词没背完，就背了一点六级，看阅读还是有一些生词，特别是词汇题。<br>但感觉我不认识的词用的不多<del>大概错了许多的</del><br>阅读整体能看懂。</p>
<h2 id="翻译"><a href="#翻译" class="headerlink" title="翻译"></a>翻译</h2><p>翻译我觉得有点难特别是<code>北至北京，南至杭州</code>我完全乱蒙。</p>
<blockquote>
<p>总之感觉还行应该能过，上不了500再考一次</p>
</blockquote>
]]></content>
      <tags>
        <tag>日记</tag>
      </tags>
  </entry>
  <entry>
    <title>CMake+GTest</title>
    <url>/2022/02/02/CMake-GTest/</url>
    <content><![CDATA[<h1 id="CMake"><a href="#CMake" class="headerlink" title="CMake"></a>CMake</h1><h2 id="CMake的作用"><a href="#CMake的作用" class="headerlink" title="CMake的作用"></a>CMake的作用</h2><p>一天小明在Windows上用VS写了一个很牛的开源项目。<br>他发到了gayhub😏上。但没有多少的star。他很疑惑。<br>然后他发现，许多gay友都是用高端的MacBook，和极客的Linux。<br>所以他写的项目，只有Windows用户能用。导致他少了许多star。</p>
<p>这时候一位gay友向他推荐了CMake。他说：“CMake可以通过源码中间件的给项目赋能，打通上游代码与下游操作系统中间的枢纽，实现闭环。”</p>
<p>“好好说话，别用互联网黑话。”小明一皮鞭下去，gay友啊啊大叫，说：“好好好，就是CMake可以让你的代码在任意系统上编译。”</p>
<p>“这才乖嘛”</p>
<p>“啪！”又是一皮鞭。</p>
<hr>
<h2 id="CMake的安装"><a href="#CMake的安装" class="headerlink" title="CMake的安装"></a>CMake的安装</h2><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>去cmake官网下载.exe的包。安装的时候把<code>Add To Path</code>勾选上。</p>
<h3 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h3><p>没有Mac不知道😭😭😭，穷死了。</p>
<h3 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h3><p>在终端输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br><span class="line">sudo apt-get install cmake</span><br></pre></td></tr></table></figure>
<h2 id="CMake的一些基本概念"><a href="#CMake的一些基本概念" class="headerlink" title="CMake的一些基本概念"></a>CMake的一些基本概念</h2><h3 id="CMakeLists-txt"><a href="#CMakeLists-txt" class="headerlink" title="CMakeLists.txt"></a>CMakeLists.txt</h3><p>这个文件会出现在项目的根目录下，和各个子目录。<br>CMakeLists.txt里面就写了CMake要干什么。</p>
<h2 id="CMakeLists-txt的基本框架"><a href="#CMakeLists-txt的基本框架" class="headerlink" title="CMakeLists.txt的基本框架"></a>CMakeLists.txt的基本框架</h2><p>假如一个项目长这样</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include</span><br><span class="line">	A.h</span><br><span class="line">	B.h</span><br><span class="line">src</span><br><span class="line">	A.cpp</span><br><span class="line">	B.cpp</span><br><span class="line">CMakeLists.txt</span><br></pre></td></tr></table></figure>
<p>那么CMakeLists.txt就长这样</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>.<span class="number">0</span>)</span><br><span class="line"><span class="keyword">project</span>(YourProjectName)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="string">&quot;include&quot;</span>)</span><br><span class="line"><span class="keyword">add_executable</span>(</span><br><span class="line">	YourExecutableFileName</span><br><span class="line">	<span class="string">&quot;src/A.cpp&quot;</span></span><br><span class="line">	<span class="string">&quot;src/B.cpp&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h2 id="CMake的使用"><a href="#CMake的使用" class="headerlink" title="CMake的使用"></a>CMake的使用</h2><p>基于上面的项目，我们在根目录下创建一个build文件夹</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">build</span><br><span class="line">include</span><br><span class="line">	A.h</span><br><span class="line">	B.h</span><br><span class="line">src</span><br><span class="line">	A.cpp</span><br><span class="line">	B.cpp</span><br><span class="line">CMakeLists.txt</span><br></pre></td></tr></table></figure>
<p>我们打开命令行（Windows是cmd）<br>进入build文件夹<br>然后执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmake ..</span><br></pre></td></tr></table></figure>
<p>然后编译</p>
<h3 id="Windows编译"><a href="#Windows编译" class="headerlink" title="Windows编译"></a>Windows编译</h3><p>Windows用户这个时候，就可以在build目录里找到.sln文件，然后用Visual Studio打开，然后编译</p>
<h3 id="Linux编译"><a href="#Linux编译" class="headerlink" title="Linux编译"></a>Linux编译</h3><p>在命令行执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>
<h3 id="Mac编译"><a href="#Mac编译" class="headerlink" title="Mac编译"></a>Mac编译</h3><p>无</p>
<h2 id="CMakeLists-txt里的一些基本命令"><a href="#CMakeLists-txt里的一些基本命令" class="headerlink" title="CMakeLists.txt里的一些基本命令"></a>CMakeLists.txt里的一些基本命令</h2><h3 id="cmake-minimum-required-VERSION-3-0-0"><a href="#cmake-minimum-required-VERSION-3-0-0" class="headerlink" title="cmake_minimum_required(VERSION 3.0.0)"></a><code>cmake_minimum_required(VERSION 3.0.0)</code></h3><p>这个命令的目的是表示 本项目cmake要求的最低版本</p>
<h3 id="project-YourProjectName"><a href="#project-YourProjectName" class="headerlink" title="project(YourProjectName)"></a><code>project(YourProjectName)</code></h3><p>这个命令的目的是表示 本项目的名字</p>
<h3 id="include-directories"><a href="#include-directories" class="headerlink" title="include_directories()"></a><code>include_directories()</code></h3><p>这个命令表示 本项目的所有源代码的<code>#include</code>的起始路径</p>
<blockquote>
<p>举个例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+include</span><br><span class="line">	+A.h</span><br><span class="line">+src</span><br><span class="line">	+A.cpp</span><br></pre></td></tr></table></figure>
<p>对于这么一个项目，A.cpp如果要include A.h<br>那么应该<code>#include &quot;../include/A.h&quot;</code><br>把CMakeLists.txt引入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+include</span><br><span class="line">	+A.h</span><br><span class="line">+src</span><br><span class="line">	+A.cpp</span><br><span class="line">+CMakeLists.txt</span><br></pre></td></tr></table></figure>

<p>CMakeLists.txt</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>.<span class="number">0</span>)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">add_executable</span>(</span><br><span class="line">	main</span><br><span class="line">	<span class="string">&quot;src/A.cpp&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>++++++++++++++++++<br>这样A.cpp里面可以只写<code>#include &quot;A.h&quot;</code></p>
</blockquote>
<h3 id="add-executable"><a href="#add-executable" class="headerlink" title="add_executable()"></a><code>add_executable()</code></h3><p>从刚刚的例子可以看到，这命令有两个参数，第一个是生成的可执行文件的名字，后面可以有好多参数，都是源代码</p>
<p>具体教程看网上吧</p>
<h1 id="GTest"><a href="#GTest" class="headerlink" title="GTest"></a>GTest</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>官网上的安装方式是每进行一次cmake都在线下载，但GTest是放在GitHub的，下载会很慢。<br>所以我提供一种本地的方法<br>先在项目的根目录下创建一个third_party文件夹<br>在third_party文件夹里打开cmd</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/google/googletest.git</span><br></pre></td></tr></table></figure>
<p>然后再CMakeLists.txt里写</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enable_testing</span>()</span><br><span class="line"><span class="keyword">add_subdirectory</span>(third_party/gtest)</span><br><span class="line"><span class="keyword">include_directories</span>(third_party/gtest/googletest/<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">add_executable</span>(</span><br><span class="line">	<span class="keyword">Test</span></span><br><span class="line">	<span class="string">&quot;test/test.cpp&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>然后在根目录下创建test文件夹，在test文件夹里面创建test.cpp<br>test.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;gtest/gtest.h&gt;</span></span></span><br><span class="line"><span class="built_in">TEST</span>(Name1,Name2)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*Test Body*/</span></span><br><span class="line">	<span class="built_in">EXPECT_EQ</span>(<span class="number">7</span>*<span class="number">8</span>, <span class="number">56</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后<code>cmake .. </code>以后编译，然后<code>ctest</code><br>就开始了测试。OK。<br>具体学习需要更加深入。多踩坑就学会了😭😭😭。</p>
<h2 id="2022-09-06-深夜"><a href="#2022-09-06-深夜" class="headerlink" title="2022-09-06 深夜"></a>2022-09-06 深夜</h2><p>新的坑出现了<br>gtest 运行测试的时候是 cmake的build目录<br>而不是cmake的binary目录</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>GAMES104--1rd</title>
    <url>/2022/03/21/GAMES104-1rd/</url>
    <content><![CDATA[<h1 id="GAMES104—1st"><a href="#GAMES104—1st" class="headerlink" title="GAMES104—1st"></a>GAMES104—1st</h1><h2 id="Game-Miracle-of-Modern-Computer-Technology"><a href="#Game-Miracle-of-Modern-Computer-Technology" class="headerlink" title="Game : Miracle of Modern Computer Technology"></a>Game : Miracle of Modern Computer Technology</h2><h2 id="Game-Engine-The-Diamond-on-the-Crown"><a href="#Game-Engine-The-Diamond-on-the-Crown" class="headerlink" title="Game Engine : The Diamond on the Crown"></a>Game Engine : The Diamond on the Crown</h2><blockquote>
<p>懂算法不等于能做出东西<br>和南理工有点相关的是，虚拟军事模拟(能水一篇论文)</p>
</blockquote>
<h2 id="The-history"><a href="#The-history" class="headerlink" title="The history"></a>The history</h2><h3 id="The-Gold-age"><a href="#The-Gold-age" class="headerlink" title="The Gold age"></a>The Gold age</h3><p>红白机：魂斗罗，马里奥等等。    无引擎，纯硬编码，极致优化（扣）</p>
<h3 id="The-father-of-Game-Engine"><a href="#The-father-of-Game-Engine" class="headerlink" title="The father of Game Engine"></a>The father of Game Engine</h3><p>John Carmack </p>
<blockquote>
<p>Wolfenstein 3D (重返德军总部)</p>
<p>Doom(毁灭战士)</p>
</blockquote>
<h3 id="Early-Age-of-Modern-Game-Engine"><a href="#Early-Age-of-Modern-Game-Engine" class="headerlink" title="Early Age of Modern Game Engine"></a>Early Age of Modern Game Engine</h3><p>GPU$\rightarrow$Quake (made by John Carmack )</p>
<p>the driver of game engine — hardware</p>
<h3 id="Modern-Game-Engine"><a href="#Modern-Game-Engine" class="headerlink" title="Modern Game Engine"></a>Modern Game Engine</h3><p>Unreal Engine, Unity,  CryEngine and so on.</p>
<h3 id="Middlewares"><a href="#Middlewares" class="headerlink" title="Middlewares"></a>Middlewares</h3><p>physics&amp;Animation , Sound , Rendering , Other.</p>
<h2 id="What-is-Game-Engine"><a href="#What-is-Game-Engine" class="headerlink" title="What is Game Engine"></a>What is Game Engine</h2><pre><code>A software framework primarily designed for the development of video games. --- Wiki
</code></pre>
<h3 id="Our-Definition-What’s-GE"><a href="#Our-Definition-What’s-GE" class="headerlink" title="Our Definition: What’s GE"></a>Our Definition: What’s GE</h3><ol>
<li><p>Technology Foundation of Matrix</p>
</li>
<li><p>Productivity Tools of Creation</p>
</li>
<li><p>Art of Complexity</p>
</li>
<li><p>(my definition) The tools of God</p>
</li>
</ol>
<h2 id="Current-the-bias"><a href="#Current-the-bias" class="headerlink" title="Current the bias"></a>Current the bias</h2><blockquote>
<p>Game Engine is not only for programmer<br>GE is a set of tools<br>Cooperating Work is important.</p>
</blockquote>
<h2 id="How-to-study"><a href="#How-to-study" class="headerlink" title="How to study"></a>How to study</h2><p>the recommend books of milo(doge)<br>Walk along the main path.<br>If we find the problems in our works in the futures, we can know what kind of book I can find the answer.</p>
<h2 id="Course-Content"><a href="#Course-Content" class="headerlink" title="Course Content"></a>Course Content</h2><ol>
<li><p>Basic Elements (MVVM设计模式 Model View ViewModel)</p>
<blockquote>
<p>看游戏引擎的源码，从update函数看起</p>
</blockquote>
</li>
<li><p>Rendering (the general framework)</p>
<blockquote>
<p>To know the details go to the Games101</p>
</blockquote>
</li>
<li><p>Animation</p>
</li>
<li><p>Physics</p>
</li>
<li><p>Gameplay(the rule of the virtual world)</p>
<blockquote>
<p>use the program to rule the  world easily</p>
</blockquote>
</li>
<li><p>Misc. System</p>
</li>
</ol>
<ul>
<li>Effects</li>
<li>Navigation</li>
<li>Camera</li>
<li>…</li>
</ul>
<ol start="7">
<li>Tool set (Need the ability of C++)</li>
</ol>
<ul>
<li>C++ Reflection</li>
<li>Data Schema</li>
</ul>
<ol start="8">
<li>Online Gaming (More and more important)</li>
</ol>
<ul>
<li>Lockstep Synchronization</li>
<li>State Synchronization</li>
<li>Consistency</li>
</ul>
<ol start="9">
<li>Advanced Technology</li>
</ol>
<ul>
<li>Motion Matching</li>
<li>Procedural Content Generation (PCG)</li>
<li>Data-Oriented Programming (DOP)</li>
<li>Job System (并行计算)</li>
<li>Lumen (UE5)</li>
<li>Nanite (UE5)</li>
</ul>
<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><p>ECS vs DOP</p>
]]></content>
      <tags>
        <tag>Games104</tag>
      </tags>
  </entry>
  <entry>
    <title>GAMES104--2rd</title>
    <url>/2022/03/21/GAMES104-2rd/</url>
    <content><![CDATA[<h1 id="Games104—2nd"><a href="#Games104—2nd" class="headerlink" title="Games104—2nd"></a>Games104—2nd</h1><h2 id="游戏引擎分层"><a href="#游戏引擎分层" class="headerlink" title="游戏引擎分层"></a>游戏引擎分层</h2><p>我们接触到的第一层Editor(工具层)<br>然后就是Rendering, Physics,Animation, Script, HUD(function)<br>然后资源管理，psd, max, maya, mp3, xml, mpeg<br>然后是核心层(瑞士军刀)<br>然后是平台层</p>
<blockquote>
<p>PC, Mac, Consoles, InputDevice, PublishingPlatforms<br>还有第三方层<br>5+1层。<br><img src="https://delta_lrd.gitee.io/pic/173.jpg"></p>
</blockquote>
<h2 id="First-task-–-做一个会动的角色"><a href="#First-task-–-做一个会动的角色" class="headerlink" title="First task – 做一个会动的角色"></a>First task – 做一个会动的角色</h2><h3 id="将资源文件变成asset"><a href="#将资源文件变成asset" class="headerlink" title="将资源文件变成asset"></a>将资源文件变成asset</h3><p>第三方文件会有很多无效文件，我们importing 资源的时候，需要转化为我们的资产asset,最好能压缩一下。<br>不同资源直接需要进行相互关联，比如模型和贴图（xml）<br>给每个资产设定一个唯一识别号guid—global unique id</p>
<h3 id="Runtime-Asset-Manager"><a href="#Runtime-Asset-Manager" class="headerlink" title="Runtime Asset Manager"></a>Runtime Asset Manager</h3><p>各种文件相互关联，需要一个Manager管理各种资源的生命周期。GC</p>
<h3 id="Function-层"><a href="#Function-层" class="headerlink" title="Function 层"></a>Function 层</h3><h4 id="Tick运行时不断跑的函数"><a href="#Tick运行时不断跑的函数" class="headerlink" title="Tick运行时不断跑的函数"></a>Tick运行时不断跑的函数</h4><p>ticklogic &amp; tickRender</p>
<h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><p>将任务拆成原子任务，小的不能再小的，然后分配给多核。</p>
<h4 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h4><p>将动画的运算放进ticklogic<br>然后渲染的时候tickrender</p>
<h3 id="核心层"><a href="#核心层" class="headerlink" title="核心层"></a>核心层</h3><h4 id="数学库"><a href="#数学库" class="headerlink" title="数学库"></a>数学库</h4><p>数学为效率服务<br>example - 卡马克快速平方根<br>SIMD加速线性代数运算<br><img src="https://delta_lrd.gitee.io/pic/171.jpg"></p>
<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>链表，二叉树。。。<br>为了避免内存碎片全部重做，</p>
<h4 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h4><ul>
<li>Memory Pool/Allocator</li>
<li>Reduce cache miss</li>
<li>Memory alignment<h4 id="可能还有网络"><a href="#可能还有网络" class="headerlink" title="可能还有网络"></a>可能还有网络</h4><h3 id="平台层"><a href="#平台层" class="headerlink" title="平台层"></a>平台层</h3><h4 id="RHI"><a href="#RHI" class="headerlink" title="RHI"></a>RHI</h4>把各个图形API的函数重新分装一遍<h4 id="硬件架构"><a href="#硬件架构" class="headerlink" title="硬件架构"></a>硬件架构</h4>手机的大小核<br>各种协处理器。。。<h3 id="工具层"><a href="#工具层" class="headerlink" title="工具层"></a>工具层</h3>蓝图，材质，UI编辑器。<br>材质编辑器保证DCC软件和引擎里看上去是一样的<br>不一定用C++<h4 id="DCC"><a href="#DCC" class="headerlink" title="DCC"></a>DCC</h4>Asset Conditioning Pipline<br>各种格式的导入导出。<h2 id="为什么要分层"><a href="#为什么要分层" class="headerlink" title="为什么要分层"></a>为什么要分层</h2>减少耦合，加强封装，增加可读性。<br>底层最好不要动，但上层可以动。减少代码改动。<blockquote>
<p>写代码之前，想想自己的代码在哪一层<br>底层不允许调用上层</p>
</blockquote>
<h2 id="Mini-Engine—Pilot-Engine来了"><a href="#Mini-Engine—Pilot-Engine来了" class="headerlink" title="Mini Engine—Pilot Engine来了"></a>Mini Engine—Pilot Engine来了</h2><h3 id="引擎分层"><a href="#引擎分层" class="headerlink" title="引擎分层"></a>引擎分层</h3></li>
<li>Editor （Tool）</li>
<li>Runtime （4层）</li>
</ul>
<p><img src="https://delta_lrd.gitee.io/pic/172.jpg"></p>
<h3 id="有多线程ECS"><a href="#有多线程ECS" class="headerlink" title="有多线程ECS!!!"></a>有多线程ECS!!!</h3>]]></content>
      <tags>
        <tag>Games104</tag>
      </tags>
  </entry>
  <entry>
    <title>GAMES104---3rd</title>
    <url>/2022/03/28/GAMES104-3rd/</url>
    <content><![CDATA[<h1 id="GAMES104—3rd"><a href="#GAMES104—3rd" class="headerlink" title="GAMES104—3rd"></a>GAMES104—3rd</h1><h2 id="游戏里有什么"><a href="#游戏里有什么" class="headerlink" title="游戏里有什么"></a>游戏里有什么</h2><ul>
<li>动态物体</li>
<li>静态物体</li>
<li>环境<ul>
<li>地形</li>
<li>天空</li>
<li>植被 （动和静都有而且量大）</li>
</ul>
</li>
<li>Trigger Area &amp; Air Wall<h2 id="这些都叫-Game-Object-GO"><a href="#这些都叫-Game-Object-GO" class="headerlink" title="这些都叫 Game Object (GO)"></a>这些都叫 Game Object (GO)</h2><h3 id="无人机例子"><a href="#无人机例子" class="headerlink" title="无人机例子"></a>无人机例子</h3><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4></li>
<li>形状</li>
<li>位置<h4 id="行为"><a href="#行为" class="headerlink" title="行为"></a>行为</h4></li>
<li>移动 … <h4 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Drone</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	vector3 pos;</span><br><span class="line">	<span class="type">float</span> health;</span><br><span class="line">	<span class="type">float</span> fuel;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">scout</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
根据这个类可以派生各种派生无人机<blockquote>
<p>早期构建方法<br>容易出现菱形继承</p>
</blockquote>
</li>
</ul>
<h3 id="解决方法-—-组件化"><a href="#解决方法-—-组件化" class="headerlink" title="解决方法 — 组件化"></a>解决方法 — 组件化</h3><h4 id="无人机"><a href="#无人机" class="headerlink" title="无人机"></a>无人机</h4><ul>
<li>Model组件</li>
<li>Motor组件</li>
<li>AI组件</li>
<li>坐标组件</li>
<li>…<h4 id="组件基类"><a href="#组件基类" class="headerlink" title="组件基类"></a>组件基类</h4>各种组件继承他<br>然后每个组件都有一个tick()函数<h2 id="Unreal-—-UObject-amp-Unity-—-Object"><a href="#Unreal-—-UObject-amp-Unity-—-Object" class="headerlink" title="Unreal — UObject &amp; Unity — Object"></a>Unreal — UObject &amp; Unity — Object</h2>用于GC的句柄，用来管理生命周期<br>每个GameObject 都继承于Object方便内存管理<h2 id="如何动起来"><a href="#如何动起来" class="headerlink" title="如何动起来"></a>如何动起来</h2>对于每个GO，运行每个组件的tick函数<br>但是现代引擎里，都是按组件tick的，（可能方便多线程）<h2 id="交互"><a href="#交互" class="headerlink" title="交互"></a>交互</h2>GO直接交互<h3 id="Event机制"><a href="#Event机制" class="headerlink" title="Event机制"></a>Event机制</h3>每个GO做个邮箱，每个组件tick的时候，先看看邮箱。<h2 id="如何管理GO"><a href="#如何管理GO" class="headerlink" title="如何管理GO"></a>如何管理GO</h2>给每个GO一个uid，pos<h3 id="场景管理"><a href="#场景管理" class="headerlink" title="场景管理"></a>场景管理</h3></li>
<li>画格子</li>
<li>BVH （现代引擎可能用）</li>
<li>BSP</li>
<li>八叉树（四叉树）</li>
<li>k-d tree</li>
<li>Scene Graph<h2 id="Takeaways"><a href="#Takeaways" class="headerlink" title="Takeaways"></a>Takeaways</h2></li>
<li>每个物体都是一个Object</li>
<li>GO可以用组件表示</li>
<li>GO的tick</li>
<li>GO使用event机制相互沟通</li>
<li>尽量先tick父GO再tick子GO</li>
<li>用邮局管理event控制时序</li>
</ul>
]]></content>
      <tags>
        <tag>Games104</tag>
      </tags>
  </entry>
  <entry>
    <title>c++ 踩坑日记</title>
    <url>/2021/12/21/c-%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="C-踩坑日记"><a href="#C-踩坑日记" class="headerlink" title="C++ 踩坑日记"></a>C++ 踩坑日记</h1><h2 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h2><p><code>A a();</code>没有这种创建对象的方法<br>只有<code>A a;</code> <code>A a = A();</code> <code>A a(10);</code> <code>A a = A(10);</code></p>
<h2 id="临时对象"><a href="#临时对象" class="headerlink" title="临时对象"></a>临时对象</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">	<span class="type">int</span> *p;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>(<span class="type">int</span> x=<span class="number">10</span>)&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;create A object&quot;</span>&lt;&lt;endl; </span><br><span class="line">		p = <span class="keyword">new</span> <span class="built_in">int</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">A</span>()&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;delete A object&quot;</span>&lt;&lt;endl;</span><br><span class="line">		<span class="keyword">delete</span> p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">str</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout&lt;&lt;*p&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A ex3 = <span class="built_in">A</span>(<span class="number">50</span>);	<span class="comment">// 1</span></span><br><span class="line">    A ex4 = ex3;	<span class="comment">// 2</span></span><br><span class="line">	ex3.<span class="built_in">str</span>(); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2 里面ex4和ex3的指针变量指向的是同一地址，他们在析构的时候会把同一个地址delete两遍，程序会出错。</p>
<p>但1里面不会，因为1里面只有一个对象，相当于把这个临时对象起了个名字ex3。</p>
<h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><p>如果你的对象是new出来的<del>好惨</del>，那么只有在delete的时候才会调用析构函数。</p>
<p>但如果是直接=出来的，系统会自己帮你调用<del>防止你带着对象跑路</del>。</p>
<h1 id="别人的问题合集"><a href="#别人的问题合集" class="headerlink" title="别人的问题合集"></a>别人的问题合集</h1><h2 id="后缀"><a href="#后缀" class="headerlink" title="后缀"></a>后缀</h2><p><code>4</code>，<code>4u</code>， <code>4ll</code>， <code>4f</code>， <code>4lf</code>这些都有什么区别</p>
<p>4 默认是 int型的</p>
<p>4u 是unsigned型的(或者unsigned int)</p>
<p>4ll 是 long long型的</p>
<p>4f 是 float型的</p>
<p>4lf是double型的</p>
<p>4.0默认是double型的</p>
<p>说这么多有什么用呢？</p>
<p>我们假设我们有一个函数<code>int f(int x)&#123;return x;&#125;</code>和<code>int f(unsigned x)&#123;return x+1;&#125;</code></p>
<p>那么我们如果调用<code>f(4)</code>那么就会返回4，但如果我们想调用第二个，我们就要用<code>f(4u)</code>这样就会返回5了。</p>
<blockquote>
<p>在有些性能要求很高的程序里，比如游戏引擎里，double就会很浪费空间，而float只占用double的一半空间。</p>
</blockquote>
<h2 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">A <span class="title">GetSelf</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">A* <span class="title">GetSelfPtr</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子里，<code>GetSelf()</code>返回的是对象本身，而<code>GetSelfPtr()</code>返回的是一个指向对象本身的指针。</p>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>日记</tag>
      </tags>
  </entry>
  <entry>
    <title>C++静态编译</title>
    <url>/2022/06/15/c-%E9%9D%99%E6%80%81%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<h1 id="C-编译"><a href="#C-编译" class="headerlink" title="C++ 编译"></a>C++ 编译</h1><h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><p>在Windows上写代码的方式其实VS是比较推荐的，但是VS过于臃肿，我不是很喜欢。<br>所以我想在Windows上用Linux的编译方式，同时我还想用现代化的LLVM+Clang。<br>经过我无数次的踩坑，我找到了一条最佳实践。</p>
<p><a href="https://winlibs.com/">WinLibs</a>上这个网站，可以下载已经编译好的在Windows上的<br><code>GCC GDB LLVM Clang lld lldb</code></p>
<p>满足我们搞事情的需求。</p>
<p>跟着官方的方式下载好我们所需要的7z的包。<br>我们解压到我们好记的位置，然后在path里添加<code>你的路径/mingw64/bin/</code></p>
<p>然后在终端里测试一下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -v</span><br><span class="line">g++ -v</span><br><span class="line">gdb -v</span><br><span class="line">clang -v</span><br><span class="line">clang++ -v</span><br><span class="line">lld -v</span><br><span class="line">lldb -v</span><br></pre></td></tr></table></figure>
<h2 id="测试正常以后，我们就可以开始搞事情了"><a href="#测试正常以后，我们就可以开始搞事情了" class="headerlink" title="测试正常以后，我们就可以开始搞事情了"></a>测试正常以后，我们就可以开始搞事情了</h2><hr>
<h2 id="单文件编译"><a href="#单文件编译" class="headerlink" title="单文件编译"></a>单文件编译</h2><h3 id="gcc-g-编译"><a href="#gcc-g-编译" class="headerlink" title="gcc/g++编译"></a><code>gcc/g++</code>编译</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello World\n&quot;</span>; </span><br><span class="line">    <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于这么一个文件我们如何用g++编译他呢</p>
<p><code>g++ main.cpp -o main.exe</code></p>
<p>这里解读一下这个命令</p>
<p><code>g++</code>表示我们用的编译器是<code>g++</code>，<br><code>main.cpp</code>是我们要编译的文件，<br><code>-o</code>表示我们编译后需要生成一个可执行文件，<br><code>main.exe</code>表示生成的可执行文件是叫<code>main.exe</code></p>
<p>这样一个cpp文件就编译好了，可以运行。</p>
<h3 id="clang编译"><a href="#clang编译" class="headerlink" title="clang编译"></a><code>clang</code>编译</h3><p>文件不变，我们改用<code>clang</code></p>
<p><code>clang++ main.cpp -o main.exe</code></p>
<p>这就不用解释了吧，和<code>g++</code>一样</p>
<blockquote>
<p>clang的具体细节还是需要自行查阅网络资料学习<br>这里只有简单操作，大佬勿喷</p>
</blockquote>
<hr>
<h3 id="C-11-或更高版本的编译"><a href="#C-11-或更高版本的编译" class="headerlink" title="C++11 或更高版本的编译"></a>C++11 或更高版本的编译</h3><p><code>g++ main.cpp -std=c++11 -o main.exe</code></p>
<p>多出来的<code>-std=c++11</code>，表示编译所用的标准（std）是c++11</p>
<p><code>clang</code>同理</p>
<p><code>clang++ main.cpp -std=c++11 -o main.exe</code></p>
<hr>
<h2 id="简单多文件编译（复杂的请用CMake）"><a href="#简单多文件编译（复杂的请用CMake）" class="headerlink" title="简单多文件编译（复杂的请用CMake）"></a>简单多文件编译（复杂的请用CMake）</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;f.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// f.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// f.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;f.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello World&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种怎么编译呢</p>
<p><code>g++ main.cpp f.cpp -std=c++11 -o main.exe</code></p>
<p>简单吧多添加一个源文件就可以了<br><code>clang</code>同理</p>
<hr>
<h2 id="静态编译"><a href="#静态编译" class="headerlink" title="静态编译"></a>静态编译</h2><p>上面介绍的编译在本地跑跑没问题，但是一旦吧编译好的文件发送给你的好基友，基友发现你这怎么缺少dll，你到底行不行</p>
<p>这种时候就很尴尬</p>
<p>原因是因为刚刚编译完的程序还是需要很多库的支持才能运行，但这些库在mingw64里面已经有了，所以编译器直接告诉程序，你要用这些的时候直接去那里面找。</p>
<p>但是把程序发给基友之后，程序就找不到他要的库了。</p>
<p>这时候静态编译就来了，我们直接把这些库都编译到一个可执行文件里不就好了，只是文件的大小变大而已<br>无伤大雅</p>
<h3 id="g-静态编译"><a href="#g-静态编译" class="headerlink" title="g++静态编译"></a><code>g++</code>静态编译</h3><p><code>g++ main.cpp -std=c++11 -o main.exe -static</code></p>
<p><code>g++</code>比较简单直接加一个参数就可以了</p>
<hr>
<h3 id="clang静态编译"><a href="#clang静态编译" class="headerlink" title="clang静态编译"></a><code>clang</code>静态编译</h3><p><code>clang++ APP.cpp -std=c++17 -o APP.exe -static -pthread -fuse-ld=lld</code></p>
<p>去网上查了一下<code>clang</code>静态编译的事，感觉资料很少，最后找到一个方式就是加三个参数，参数我也不知道什么意思，总之写上就能运行了，实测。</p>
<p>The End</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/12/17/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>vscode c++ 配置</title>
    <url>/2022/08/17/vscode-c-%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="vscode"><a href="#vscode" class="headerlink" title="vscode"></a>vscode</h1><p>vscode是微软推出的一款编辑器,他有着好看的外观<del>最重要了</del>,非常良好的拓展性</p>
<p>但vscode说到底还是一个编辑器而不是IDE</p>
<p>所以我要把打造成一个我用着舒服的写代码的工具</p>
<h1 id="编译器的选择"><a href="#编译器的选择" class="headerlink" title="编译器的选择"></a>编译器的选择</h1><p>主流编译器有gcc/g++,clang/clang++,MSVC</p>
<h2 id="MSVC"><a href="#MSVC" class="headerlink" title="MSVC"></a>MSVC</h2><p>微软的编译器Visual Studio的东西,太臃肿我不想用</p>
<h2 id="gcc-g"><a href="#gcc-g" class="headerlink" title="gcc/g++"></a>gcc/g++</h2><p>非常常见的编译器,但听说错误显示不太好,保留。</p>
<h2 id="clang-clang"><a href="#clang-clang" class="headerlink" title="clang/clang++"></a>clang/clang++</h2><p>听说是一个比较现代的编译器</p>
<hr>
<p>而我最后的选择是,除了MSVC我都要</p>
<p>但是clang和gcc在window上的安装非常繁琐且无意义(个人感觉)</p>
<h1 id="编译器的安装"><a href="#编译器的安装" class="headerlink" title="编译器的安装"></a>编译器的安装</h1><p>这里推荐一个网站叫做<a href="https://winlibs.com/">WinLibs</a></p>
<p>在里面下载UCRT runtime的64位的最新版</p>
<p>解压到喜欢的位置比如<code>D:/</code></p>
<p>解压后应该有个<code>D:/mingw64</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mingw64</span><br><span class="line">|-- bin</span><br><span class="line">|-- build-info.txt</span><br><span class="line">|-- etc</span><br><span class="line">|-- include</span><br><span class="line">|-- lib</span><br><span class="line">|-- libexec</span><br><span class="line">|-- licenses</span><br><span class="line">|-- opt</span><br><span class="line">|-- share</span><br><span class="line">|-- version_info.txt</span><br><span class="line">`-- x86_64-w64-mingw32</span><br><span class="line"></span><br><span class="line">9 directories, 2 files</span><br></pre></td></tr></table></figure>

<p>按下win键,搜索path,找到<code>编辑系统环境变量</code>打开,</p>
<p>打开环境变量,</p>
<p>在系统变量里找到<code>path</code>双击,然后点击新建,</p>
<p>输入<code>$&#123;解压的路径&#125;\bin</code>,以我的为例子就是<code>D:\mingw64\bin</code></p>
<p>现在打开一个新的终端(cmd或者powershell或者window terminal), 输入<br><code>gcc -v</code></p>
<p><code>g++ -v</code></p>
<p><code>gdb -v</code></p>
<p><code>clang -v</code> (可选)</p>
<p><code>clang++ -v</code> (可选)</p>
<p><code>lldb -v</code> (可选)</p>
<p>如果都没有XXX not found的字样,就表示安装成功</p>
<h1 id="编译器的使用"><a href="#编译器的使用" class="headerlink" title="编译器的使用"></a>编译器的使用</h1><p>我们这里以gcc为例编译一个<code>HelloWorld.c</code></p>
<p>我们打开vscode,打开一个文件夹,新建一个<code>HelloWorld.c</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">#include &quot;stdlib.h&quot;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;HelloWorld\n&quot;);</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打开vscode的终端</p>
<p>输入<code>gcc HelloWorld.c -o HelloWorld.exe</code></p>
<p>等待一会以后<br>输入<code>.\HelloWorld.exe</code></p>
<p>如果出现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HelloWorld</span><br><span class="line">请按任意键继续. . . </span><br></pre></td></tr></table></figure>
<p>那么就成功编译了一个程序</p>
<p>现在来解释命令的含有</p>
<p><code>gcc</code>表示我要用gcc这个编译器</p>
<p><code>HelloWorld.c</code>表示我要编译HelloWorld.c这个文件</p>
<p><code>-o</code> 表示我要生成一个可执行文件(在Windows上后缀是.exe 在Linux上没有后缀)</p>
<p><code>HelloWorld.exe</code> 表示我需要的可执行文件的名称</p>
<p>现在编译程序的基础只是我们明白了</p>
<p>接下里我们就要开始配置vscode了</p>
<h1 id="vscode配置"><a href="#vscode配置" class="headerlink" title="vscode配置"></a>vscode配置</h1><p>vscode运行c++程序需要两个文件</p>
<p>分别为<code>launch.json</code>和<code>tasks.json</code></p>
<h2 id="简易版配置"><a href="#简易版配置" class="headerlink" title="简易版配置"></a>简易版配置</h2><p>在打开的文件夹里创建<code>.vscode</code>文件夹,注意是文件夹</p>
<p>在<code>.vscode</code>里面创建<code>launch.json</code>和<code>tasks.json</code></p>
<p><code>launch.json</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;version&quot;: &quot;0.2.0&quot;,</span><br><span class="line">    &quot;configurations&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;Launch&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;cppdbg&quot;,</span><br><span class="line">            &quot;request&quot;: &quot;launch&quot;,</span><br><span class="line">            &quot;program&quot;: &quot;$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe&quot;,</span><br><span class="line">            &quot;miDebuggerPath&quot;: &quot;D:\\mingw64\\bin\\gdb.exe&quot;,</span><br><span class="line">            &quot;externalConsole&quot;: true,</span><br><span class="line">            &quot;cwd&quot;: &quot;$&#123;fileDirname&#125;&quot;,</span><br><span class="line">            &quot;preLaunchTask&quot;: &quot;g++&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>&quot;miDebuggerPath&quot;: &quot;D:\\mingw64\\bin\\gdb.exe&quot;,</code>,路径替换为安装路径</p>
<p>task.json</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;tasks&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;type&quot;: &quot;cppbuild&quot;,</span><br><span class="line">            &quot;label&quot;: &quot;g++&quot;,</span><br><span class="line">            &quot;command&quot;: &quot;D:\\mingw64\\bin\\g++.exe&quot;,</span><br><span class="line">            &quot;args&quot;: [</span><br><span class="line">                &quot;-fdiagnostics-color=always&quot;,</span><br><span class="line">                &quot;-std=c++17&quot;,</span><br><span class="line">                &quot;-g&quot;,</span><br><span class="line">                &quot;$&#123;file&#125;&quot;,</span><br><span class="line">                &quot;-o&quot;,</span><br><span class="line">                &quot;$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span><br><span class="line">            ],</span><br><span class="line">            </span><br><span class="line">            &quot;problemMatcher&quot;: [</span><br><span class="line">                &quot;$gcc&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;group&quot;: &#123;</span><br><span class="line">                &quot;kind&quot;: &quot;build&quot;,</span><br><span class="line">                &quot;isDefault&quot;: true</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;detail&quot;: &quot;调试器生成的任务。&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;version&quot;: &quot;2.0.0&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同理其中<code>&quot;command&quot;: &quot;D:\\mingw64\\bin\\g++.exe&quot;,</code>换成安装路径,<code>g++.exe</code> 可以换成 <code>gcc.exe</code> 根据要写的代码的语言决定,c和c++都可以用g++,gcc只能对c起作用,所以推荐g++</p>
<p>然后切换到刚刚的HelloWorld.c (十分重要<del>我当初在这里踩坑好久</del>)</p>
<p>然后点击左边的运行于调试,再点击绿色的三角形开始编译调试代码</p>
<h2 id="launch-json-详细解释"><a href="#launch-json-详细解释" class="headerlink" title="launch.json 详细解释"></a>launch.json 详细解释</h2><p><code>launch.json</code>主要是配置调试器(debugger)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;version&quot;: &quot;0.2.0&quot;,</span><br><span class="line">    &quot;configurations&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;Launch&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;cppdbg&quot;,</span><br><span class="line">            &quot;request&quot;: &quot;launch&quot;,</span><br><span class="line">            &quot;program&quot;: &quot;$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe&quot;,</span><br><span class="line">            &quot;miDebuggerPath&quot;: &quot;D:\\mingw64\\bin\\gdb.exe&quot;,</span><br><span class="line">            &quot;externalConsole&quot;: true,</span><br><span class="line">            &quot;cwd&quot;: &quot;$&#123;fileDirname&#125;&quot;,</span><br><span class="line">            &quot;preLaunchTask&quot;: &quot;g++&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>&quot;version&quot;</code> 表示版本对于单文件来说没啥意义(个人感觉)</p>
<p><code>&quot;configurations&quot;</code> 表示这是一个配置,以下是配置的内容</p>
<p><code>&quot;name&quot;</code> 顾名思义是名字,随便取</p>
<p><code>&quot;type&quot;</code> 配置的类型,默认cppdbg就行</p>
<p><code>&quot;request&quot;:&quot;launch&quot;</code> 表示这个配置需要被vscode的launch命令调用</p>
<p><code>&quot;programe&quot;: &quot;$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</code> 表示我们需要调试的程序的名字</p>
<blockquote>
<p>${fileDirname} 表示当前活动的文件(就是一闪一闪的|所在的文件)的文件夹的名字</p>
</blockquote>
<blockquote>
<p>{fileBasenameNoExtension} 表示当前活动的文件的不带后缀的文件名</p>
</blockquote>
<p><code>&quot;miDebuggerPath&quot;</code> 调试器debugger所在的位置</p>
<p><code>&quot;externalConsole&quot;</code> 是否开始额外的控制台</p>
<p><code>&quot;cwd&quot;</code> 运行程序是所处的位置 console work directory</p>
<blockquote>
<p>比如A.exe需要A.jpg才能运行 </p>
<p>但是</p>
<p>A.exe 在 C:/A.exe </p>
<p>A.jpg在 D:/A.jpg </p>
<p>这时候如果我们指定 “cwd” 为 D:</p>
<p>那么程序就可以正常运行</p>
</blockquote>
<p><code>&quot;preLaunchTask&quot;</code> 前置任务,这个值必须和<code>task.json</code>里的<code>label</code>一致</p>
<h2 id="tasks-json"><a href="#tasks-json" class="headerlink" title="tasks.json"></a>tasks.json</h2><p><code>tasks.json</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;tasks&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;type&quot;: &quot;cppbuild&quot;,</span><br><span class="line">            &quot;label&quot;: &quot;g++&quot;,</span><br><span class="line">            &quot;command&quot;: &quot;D:\\mingw64\\bin\\g++.exe&quot;,</span><br><span class="line">            &quot;args&quot;: [</span><br><span class="line">                &quot;-fdiagnostics-color=always&quot;,</span><br><span class="line">                &quot;-std=c++17&quot;,</span><br><span class="line">                &quot;-g&quot;,</span><br><span class="line">                &quot;$&#123;file&#125;&quot;,</span><br><span class="line">                &quot;-o&quot;,</span><br><span class="line">                &quot;$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span><br><span class="line">            ],</span><br><span class="line">            </span><br><span class="line">            &quot;problemMatcher&quot;: [</span><br><span class="line">                &quot;$gcc&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;group&quot;: &#123;</span><br><span class="line">                &quot;kind&quot;: &quot;build&quot;,</span><br><span class="line">                &quot;isDefault&quot;: true</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;detail&quot;: &quot;调试器生成的任务。&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;version&quot;: &quot;2.0.0&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>&quot;tasks&quot;</code> 存放任务的数组</p>
<p>写不动了先写到这~~~</p>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>年末总结</title>
    <url>/2021/12/31/%E5%B9%B4%E6%9C%AB%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="年末总结"><a href="#年末总结" class="headerlink" title="年末总结"></a>年末总结</h1><p>看到网上好多up都在做年末总结，空间也是。那我也来一个年末总结看看今年都干了什么事</p>
<h2 id="大学前"><a href="#大学前" class="headerlink" title="大学前"></a>大学前</h2><p>高考前都没什么好说的，刷卷子，备战高考。<br>但高考考的也不是很理想，数学圆锥曲线明明做过类似的，但考场时脑子一片空白。状态真的太重要了。<br>然后来到了南京理工大学，没进我想去的计算机，来到了能动。</p>
<h3 id="暑假"><a href="#暑假" class="headerlink" title="暑假"></a>暑假</h3><p>暑假比较空闲就学了一个车，考完了科二。<br>还搞了搞Vulkan，但这玩意太复杂了，抄样例抄了一段时间就打算放弃了，决定从OPENGL开始。</p>
<h2 id="大学后"><a href="#大学后" class="headerlink" title="大学后"></a>大学后</h2><h3 id="课业"><a href="#课业" class="headerlink" title="课业"></a>课业</h3><p>大学的生活与高中完全不一样。有很多自己的时间。但现在来看，这些自己的时间如果没好好利用真的超级亏。这不是空话，因为我数学真的不行了才发现自己浪费掉好多刷数学的时间，现在考试都是个问题。</p>
<h3 id="与hfc大佬的开发"><a href="#与hfc大佬的开发" class="headerlink" title="与hfc大佬的开发"></a>与hfc大佬的开发</h3><p>在这些自己的时间里，我有幸和何丰辰一起开发一个类南理助手的软件，但完成度实在是太低了，鸽到现在。</p>
<h3 id="OpenGL"><a href="#OpenGL" class="headerlink" title="OpenGL"></a>OpenGL</h3><p>之后又自己学了一点OPENGL，希望以后能自己搞出个游戏引擎。学到了纹理之后。就开始准备备考期末考试了。</p>
<h3 id="编程比赛"><a href="#编程比赛" class="headerlink" title="编程比赛"></a>编程比赛</h3><p>期间我还去南理的编程新生赛，侥幸拿了一个一等奖<del>一等奖最后一名</del>。</p>
<h3 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h3><p>在高中有过想搞一个自己的图床，打算用来做博客的。备考前一段时间我把博客大概搭完了。但想分享给以前的同学的时候发现，何大佬搞了一个Django的博客。orz。就没好意思发。</p>
<h3 id="和npy的网站"><a href="#和npy的网站" class="headerlink" title="和npy的网站"></a>和npy的网站</h3><p>但看到大佬的Django网站，我又想搞一个我和我npy的网站，专门用来放我和她的美好回忆。现在已经实现了文件上传这一个功能。但实在是太丑了，自己也不是很想去学前端。所以这个就放以后吧。</p>
<h3 id="手写公式识别"><a href="#手写公式识别" class="headerlink" title="手写公式识别"></a>手写公式识别</h3><p>搭完了博客我又有了一个想法。就是写博客的时候我可能会用到数学公式，而写Latex的数学公式又太麻烦了，记不住。所以我想用百度智慧云的公式识别API来做过手机APP，直接手写然后拍照就能转换为Latex公式。这样就方便多了。<br>一入Android深似海。我需要用Java写安卓。虽然Java写起来很爽，IDEA各种自动不全，随随便便100多行就出来了，而且还实现了APP调用摄像头拍照，生成缩略图，但是Java的各种Buffer真的是太绕了而且干个啥都要import一个名字贼长的东西。<br>但在调用API的时候怎么弄怎么出错，明明已经在非安卓环境下测试成功了T_T。<br>然后我去网上看了看，安卓进行网络操作必须用多线程。T_T<br>这就是今年我干过的蠢事。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>回顾这一年，我鸽了好多东西。T_T<br>好多是我能力不足。有好多是因为我懒不想继续去深入。而且我还想花时间去玩，去看视频。但其实想想去玩，去看视频的这些时间用来学习，就可以兼顾学习和自己的兴趣了。<br>明年我的目标是，寒假提前学掉一点课程，开学之后直接当复习。一旦有时间就去学习开发，而不是看视频。<br>好好开始打Codeforces，而不是想现在一样用学习当挡箭牌放任自己。</p>
]]></content>
      <tags>
        <tag>日记</tag>
      </tags>
  </entry>
  <entry>
    <title>我的欺诈师女友</title>
    <url>/2022/01/01/%E6%88%91%E7%9A%84%E6%AC%BA%E8%AF%88%E5%B8%88%E5%A5%B3%E5%8F%8B/</url>
    <content><![CDATA[<h1 id="《我的npy是最强欺诈师》"><a href="#《我的npy是最强欺诈师》" class="headerlink" title="《我的npy是最强欺诈师》"></a>《我的npy是最强欺诈师》</h1><p>就在元旦的前一天，我的npy告诉我，公安局的人要来找他了。</p>
<p>我听到后一脸震惊，心想平时那么可爱的npy做了什么事，居然被警察叔叔盯上了。我着急的问她：“你干嘛了？警察为啥要来找你？”</p>
<p>“我骗了一个人的钱。。。”</p>
<p>我沉默了一会，搜索了一下诈骗罪立案要求，百度上写的是￥3000。</p>
<p>“你骗了谁的钱，骗了多少，3000才能立案，你应该不到吧。”</p>
<p>“正好3000 。”</p>
<p>牛，是我心里第一个崩出来的字。上生物课都不敢看牛蛙的她，骗钱这么猛的嘛。转念间，我心里一颤，心想：“她和我贪恋爱不会也因为钱吧，不可能，要是这样找我干嘛，而且到现在也没问我要过钱。不会是想和我对口供吧。”</p>
<p>“你好好说说到底怎么骗的。”</p>
<p>“就不小心骗了嘛，然后那个反诈中心一直给我打电话，还说要按流程让我和警察见一面。”</p>
<p>“真甜美的，你不会真的要进去了吧？”</p>
<p>“我要是真进去了你会不要我吗？”</p>
<p>“当然不会，你要不赶紧去自首吧。。。或者你赶紧把钱还给人家。你好好说说你怎么骗的，金额小应该不会判很重。”</p>
<p>“哈哈哈哈哈哈哈哈哈哈哈，骗你的傻子。”</p>
<p>“？？？”</p>
<p>“但警察要见我是真的。”</p>
<p>“？？？”</p>
<p>“这两天反诈中心一直给我打电话，问我有没有被骗，还说要按流程要和警察见一面，1月4号我就要去见一面了。这两天被这电话弄的烦死了。”</p>
<p>听她这么说，我好像回忆起来之前B站有up主做视频解密各种网上的高回报兼职，然后也被警察谈话了的。</p>
<p>“你吓死我了”</p>
<p>“哈哈哈哈哈哈哈哈哈哈哈”</p>
]]></content>
      <tags>
        <tag>日记</tag>
      </tags>
  </entry>
  <entry>
    <title>用CMake-Clangd-vscode学习项目</title>
    <url>/2022/07/21/%E7%94%A8CMake-Clangd-vscode%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<p>网上许多文章都让新手去学习开源项目，这很好，但是把C++的开源项目头文件和源文件是用cmake管理的，所以用vscode打开就会各种找不到头文件报错。</p>
<p>但是我还是想用vscode来学习怎么办我们可以这样搞：</p>
<h2 id="vscode-安装-clangd"><a href="#vscode-安装-clangd" class="headerlink" title="vscode 安装 clangd"></a>vscode 安装 clangd</h2><p>在vscode的拓展里面搜索clangd并且安装</p>
<p>clangd是一个非常好用的智能提醒和补全工具比vscode自带的好用多了</p>
<h2 id="cmake配置项目"><a href="#cmake配置项目" class="headerlink" title="cmake配置项目"></a>cmake配置项目</h2><p>clangd可以自动识别cmake生成的compile_commands.json来进行头文件的识别</p>
<p>但是compile_commands.json不会自动生成，并且只能在<code>Makefile</code>和<code>Ninja</code>的模式下生成</p>
<p>MSVC还是老老实实用Visual Studio吧</p>
<p>我以<code>Ninja+clang</code>为例</p>
<p>进入项目根目录后</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake .. -G &quot;Ninja&quot; -DCMAKE_C_COMPILER=&quot;D:/mingw64/bin/clang.exe&quot; -DCMAKE_CXX_COMPILER=&quot;D:/mingw64/bin/clang++.exe&quot; -DCMAKE_EXPORT_COMPILE_COMMANDS=ON</span><br><span class="line"><span class="built_in">cd</span> ..</span><br></pre></td></tr></table></figure>

<p>然后用vscode打开clangd就会自动帮你配置好你需要的东西<br>perfect！</p>
<hr>
<h3 id="G-quot-Ninja-quot"><a href="#G-quot-Ninja-quot" class="headerlink" title="-G &quot;Ninja&quot;"></a><code>-G &quot;Ninja&quot;</code></h3><p>这个就表示 我要用Ninja来编译我的项目</p>
<hr>
<h3 id="DCMAKE-C-COMPILER-quot-D-mingw64-bin-clang-exe-quot"><a href="#DCMAKE-C-COMPILER-quot-D-mingw64-bin-clang-exe-quot" class="headerlink" title="-DCMAKE_C_COMPILER=&quot;D:/mingw64/bin/clang.exe&quot;"></a><code>-DCMAKE_C_COMPILER=&quot;D:/mingw64/bin/clang.exe&quot;</code></h3><p><code>-D</code> 这个表示我要定义一个宏定义</p>
<p><code>CMAKE_C_COMPILER=&quot;&quot;</code> 表示我的C语言的编译器的路径是…</p>
<p><code>CMAKE_CXX_COMPILER=&quot;&quot;</code> 同理表示C++的编译器的路径是…</p>
<hr>
<h3 id="导出编译命令-DCMAKE-EXPORT-COMPILE-COMMANDS-ON"><a href="#导出编译命令-DCMAKE-EXPORT-COMPILE-COMMANDS-ON" class="headerlink" title="导出编译命令 -DCMAKE_EXPORT_COMPILE_COMMANDS=ON"></a>导出编译命令 <code>-DCMAKE_EXPORT_COMPILE_COMMANDS=ON</code></h3><p><code>-DCMAKE_EXPORT_COMPILE_COMMANDS=ON</code> 表示我要导出我的编译命令好让别的软件用</p>
<hr>
<h2 id="实战-leveldb"><a href="#实战-leveldb" class="headerlink" title="实战 leveldb"></a>实战 leveldb</h2><p><code>git clone https://github.com/google/leveldb.git</code> 先把项目克隆下来</p>
<p><code>cd leveldb</code>进入项目根目录</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">cmake .. -G &quot;Ninja&quot; -DCMAKE_C_COMPILER=&quot;D:/mingw64/bin/clang.exe&quot; -DCMAKE_CXX_COMPILER=&quot;D:/mingw64/bin/clang++.exe&quot; -DCMAKE_EXPORT_COMPILE_COMMANDS=ON</span><br></pre></td></tr></table></figure>
<p>cmake配置</p>
<p><code>cd ..</code> 返回根目录<br><code>code .</code> 用vscode打开</p>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>CMake</tag>
      </tags>
  </entry>
</search>
